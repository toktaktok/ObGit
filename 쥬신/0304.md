폴리곤 중에서 "위쪽" 을 바라보는 면에만 충돌 처리를 할 수 있도록 하면 부하를 줄일 수 있다.
이를 따로 저장해 놓았다가, 충돌 처리를 돌도록

메쉬를 로드할 때 변과 인접한 세 이웃에 대한 정보를 저장해 놓고, 이후 충돌 처리할 때 이웃들에만 검사한다고 한다면 도움이 될 듯(근데 빡셈)
지형 태울때만 이용해라

### 수업
OffsetMatrix를 저장해 놨다가, 쉐이더에 g_BoneMatrix라는 이름으로 같이 바인딩한다.

모델 밑에
`_float4x4 m_BoneMatrices[512]`
멤버 변수를 만들어 둔다. 512개인 이유는 뼈 갯수가 최대 512개이기 때문에.

`CShader::Bind_Matrices` 함수 추가.
`pMatrixVariable->SetMatrixArray` 함수 호출하여 행렬 여러개 같이 바인딩

메쉬를 돌 때 뼈들 주소, 행렬 배열 주소를 보내 메쉬에서 이를 채워주게 한다.
뼈에서 콤바인 행렬 Get함수 생성.

애니메이션 관리 시 일회성, 반복 재생 상태 설정하도록.

피오나 모델의 칼 같은 경우, 뼈 정보가 따로 존재하지 않는다. -> 칼 자체에 애니메이션이 붙어 있지 않기 때문.
피오나 모델 안의 sword 메쉬와 마찬가지로 AnimModel 전용으로 메쉬를 로드했을 텐데, 뼈가 존재하지 않았으므로 해당 변수에 0이 들어갔다.
쉐이더에서는 영향을 주는 뼈의 상태를 기준으로 위치를 맞춰 주는데, 이때 곱해지는 행렬이 0이 되어버리므로 뼈가 없는 메쉬들이 아예 그려지지 않게 된 것.

모델로 따라 들어가면 **메쉬의 이름과 동일한 이름을 가진 뼈가 존재.**
(애니메이션 없는 모델의 경우 미리 위치를 맞춰 주기 때문에, 상관이 없음.)

``` cpp
//만약 메쉬에 대한 뼈가 하나도 없다면
if(0 == m_iNumBones)
{
	m_iNumBones = 1;
	//메쉬 이름과 똑같은 이름의 뼈의 인덱스를 찾는다. 이걸 m_Bones에 추가한다.
	
}
```

쉐이더에서 weight 값을 다시 구한다.
`weightW = 1.f - (weightX + weightY + weightZ)`
나머지 값이 모두 0이라면 하나라도 있는 뼈의 움직임을 그대로 따라가도록.

이 메쉬에 오프셋을 항등으로 미리 추가.
##### 애니메이션 모델의 Transform Matrix? 
처음 상태를 수정하고 싶을 때, Invalidate 함수에서  루트 노드에게만 한 번 곱해주도록.

aiNode = 상속 관계
aiBone = 어떤 정점들에게 영향을 주는지
aiAnimNode = 